// docs/replit-ai-brief.md
# eDiscovery (PST) — Build Brief for Replit AI

## Goal
Build an internal eDiscovery tool for claims consulting that ingests **.pst** (Outlook export) files **once**, normalizes and indexes emails in Postgres (metadata + plain text), adds **hybrid search** (Postgres full-text + vector embeddings), and provides a clean UI to upload, monitor ingestion, and search by keywords, parties, and dates. Keep the original PST/EML for provenance; do **not** search the PST directly.

## Stack & Constraints (follow exactly)
- **Frontend:** React 18 + TypeScript, Vite, Wouter, Tailwind (custom theme), shadcn/ui, Lucide, TanStack Query v5, React Hook Form + Zod. State via Context (+ React Query).
- **Backend:** Node.js + TypeScript (tsx), Express, express-session + connect-pg-simple, Passport Local, bcryptjs(10).
- **DB:** PostgreSQL (Neon on Replit) + **Drizzle ORM**. Migrations via `npm run db:push`. Zod at all API edges.
- **Search:** Postgres FTS (`tsvector`) + **pgvector** for embeddings.
- **Storage:** Replit Object Storage (GCS) or local dev folder; uploads via multer.
- **Parsing:** Use `readpst` CLI (libpst) to explode PST → .eml (preferred) or a Node PST lib if available.
- **No websockets.** Freshness via React Query refetch/invalidations.
- **Multi-tenancy:** Company → BU → Project hierarchy exists; every row has `company_id`. All queries **must** filter by it. RBAC with time-boxed role history.

## Non-negotiable Security
- Sessions httpOnly; secure in prod. Hash passwords with bcryptjs(10).
- Validate **every** `params/query/body` with Zod. Never trust client tenancy inputs.
- Chain-of-custody: store SHA-256 for PST + each email/body and attachment.
- Audit later: who ingested/downloaded/exported.

## Data Model (new tables)
- `ediscovery_uploads`: id, company_id, filename, storage_key, size, sha256, status(`pending|processing|complete|failed`), error, created_at, processed_at.
- `ediscovery_emails`: id, company_id, upload_id, message_id, thread_id, subject, from_address, to/cc/bcc (jsonb string[]), sent_at, has_attachments, body_text, snippet, sha256, **embedding vector(1536)**, **search_vector tsvector (GENERATED)**.
- `ediscovery_attachments`: id, company_id, email_id, filename, content_type, size, sha256, storage_key.

**Indexes/Ext:**
- `CREATE EXTENSION IF NOT EXISTS "vector";`
- `CREATE INDEX ... GIN (search_vector);`
- `CREATE INDEX ... IVFFLAT (embedding vector_cosine_ops) WITH (lists=100);`
- Trigram optional for address like/ilike.

## Ingestion Workflow
1. **Upload PST** → saved to object storage (or local dev folder). Record SHA-256.
2. **Kick ingest job** (in-process first; later move to a queue).
3. **Extract EMLs** via `readpst -e -D -o <tmp>`; parse headers/body.
4. **Normalize + insert** email rows (addresses lower-cased & trimmed), attachment metadata.
5. **Compute embedding** from `subject + addresses + body_text` (OpenAI `text-embedding-3-small` for cost; 1536 dims).
6. **Status** flips `pending → processing → complete` (or `failed` with error).

> Decision: **Search the DB**, not the PST. Keep PST/EML for download/provenance only.

## Search (Hybrid Ranking)
- Endpoint computes:
  - `ts_rank_cd(search_vector, plainto_tsquery('english', :q))` ⇒ **text score**.
  - `1 - (embedding <=> :query_embedding)` ⇒ **semantic score** (cosine similarity).
- Final score: `0.6 * text_score + 0.4 * semantic_score`. Tune later.
- Filters: `from`, `to`, `parties[]` (match in from/to/cc/bcc), `dateFrom`, `dateTo`, `hasAttachments`.

## API Surface (all behind auth + tenant filter)
- `POST /ediscovery/uploads` — multipart `file=.pst` → `{ uploadId }`.
- `POST /ediscovery/ingest/:id` — idempotent start; returns `{ status }`.
- `GET  /ediscovery/uploads/:id` — returns upload row; poll `status`.
- `GET  /ediscovery/emails` — query params:  
  `q, from, to, parties=a@x.com,b@y.com, dateFrom=YYYY-MM-DD, dateTo=YYYY-MM-DD, limit, offset`  
  Returns `{ items: [{ id, subject, snippet, fromAddress, toAddresses, sentAt, score }] }`.
- `GET  /ediscovery/emails/:id` — returns `{ email, attachments }`.

### Validation
Define Zod schemas at the router boundary; coerce numbers/dates; sanitize email arrays; enforce `company_id` from session context, never from client.

## UI (single route `/ediscovery`)
- **Header** + quick help tooltip on PST ingestion.
- **Upload Card**: file input (`.pst`), “Upload & Ingest” button, status badge (poll until `complete`).
- **Search Bar**: one input (natural language or keywords), “Filters” button to toggle a panel with parties and date pickers.
- **Results Table**: subject, from, to (truncated), sent date, score; click a row opens **Email Drawer** (right sheet) showing headers, body (pre), attachments list.
- **React Query**: invalidate emails on query change; `refetchOnWindowFocus: 'always'` for the results key.

## Env / Secrets (Replit)
- `DATABASE_URL` (Neon)
- `SESSION_SECRET`
- `OPENAI_API_KEY`
- `OBJECT_STORAGE_*` (if using GCS), else local `LOCAL_STORAGE_DIR`

## Definition of Done
- Upload a small PST → status flows `pending→processing→complete` without server crash.
- Searching “contract variation July 2022” returns relevant hits ranked sensibly.
- Parties filter with multiple emails narrows results across from/to/cc/bcc.
- Email detail loads within < 300ms from DB; attachment metadata present.
- All queries include `company_id` in WHERE. Unauthenticated request returns 401.
- Basic load: 100k emails ingest < 30 min on dev; query P95 < 500ms with indexes built.

## Stretch (post-v1)
- Attachment text extraction (PDF/Word: pdf parsing + `mammoth`), indexed separately.
- Party aliasing (map multiple addresses/domains → a single “person”).
- Export set (CSV or ZIP of EMLs) with audit events.
- Job queue (BullMQ) + worker process for ingest; resumable ingest by upload id.
- Threading via `Message-Id`/`In-Reply-To`/`References`.

## Guardrails Checklist
- ✅ Zod on all inputs; consistent error shape.
- ✅ Multi-tenant WHERE clauses; no client-provided company ids.
- ✅ Session cookie httpOnly; secure in prod.
- ✅ SHA-256 on PST + email body; don’t mutate originals.
- ✅ Indices created before heavy queries run.
